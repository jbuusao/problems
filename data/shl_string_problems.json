{
  "problems": [
    {
      "id": 16,
      "title": "Palindrome Checker with Preprocessing",
      "statement": "Write a function that determines if a given string is a palindrome, considering only alphanumeric characters and ignoring case. For example, 'A man, a plan, a canal: Panama' should return True because when we consider only alphanumeric characters and ignore case, it reads the same forwards and backwards. Empty strings should be considered palindromes.",
      "function_signature": "def is_palindrome(s):",
      "categories": ["string_processing", "pattern_recognition"],
      "python_constructs": ["string_methods", "two_pointers", "regular_expressions"],
      "hints": [
        "Remove all non-alphanumeric characters and convert to lowercase first",
        "Use two pointers approach from start and end of the cleaned string",
        "Compare characters moving inward until pointers meet"
      ],
      "solution": "def is_palindrome(s):\n    import re\n    \n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    \n    # Empty string is considered a palindrome\n    if not cleaned:\n        return True\n    \n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True",
      "test_cases": [
        {"input": ["A man, a plan, a canal: Panama"], "expected": true},
        {"input": ["race a car"], "expected": false},
        {"input": [""], "expected": true},
        {"input": ["Madam"], "expected": true},
        {"input": ["12321"], "expected": true}
      ]
    },
    {
      "id": 17,
      "title": "Anagram Detection System",
      "statement": "Create a function that checks if two strings are anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequencies, ignoring case and spaces. For example, 'listen' and 'silent' are anagrams. Return True if they are anagrams, False otherwise.",
      "function_signature": "def are_anagrams(str1, str2):",
      "categories": ["string_processing", "data_structure_fundamentals"],
      "python_constructs": ["collections_counter", "string_methods", "dictionary"],
      "hints": [
        "Remove spaces and convert both strings to lowercase for comparison",
        "Use Counter or frequency dictionaries to count character occurrences",
        "Compare the character frequency maps of both strings"
      ],
      "solution": "def are_anagrams(str1, str2):\n    from collections import Counter\n    \n    # Remove spaces and convert to lowercase\n    clean_str1 = str1.replace(' ', '').lower()\n    clean_str2 = str2.replace(' ', '').lower()\n    \n    # If lengths are different, they can't be anagrams\n    if len(clean_str1) != len(clean_str2):\n        return False\n    \n    # Count character frequencies\n    return Counter(clean_str1) == Counter(clean_str2)",
      "test_cases": [
        {"input": ["listen", "silent"], "expected": true},
        {"input": ["evil", "vile"], "expected": true},
        {"input": ["hello", "bello"], "expected": false},
        {"input": ["", ""], "expected": true},
        {"input": ["a gentleman", "elegant man"], "expected": true}
      ]
    },
    {
      "id": 18,
      "title": "Reverse Words in String",
      "statement": "Given a string containing words separated by spaces, reverse the order of words while preserving the spacing. Leading and trailing spaces should be preserved, and multiple spaces between words should be maintained. For example, '  hello   world  ' should become '  world   hello  '.",
      "function_signature": "def reverse_words_preserve_spacing(s):",
      "categories": ["string_processing", "array_manipulation"],
      "python_constructs": ["string_split", "list_reversal", "string_join"],
      "hints": [
        "Split the string by spaces but keep track of the spacing pattern",
        "Use split() to get words and find spaces between them",
        "Reverse the words list and reconstruct with original spacing"
      ],
      "solution": "def reverse_words_preserve_spacing(s):\n    if not s:\n        return s\n    \n    # Find all words (non-space sequences)\n    words = []\n    current_word = ''\n    \n    for char in s:\n        if char != ' ':\n            current_word += char\n        else:\n            if current_word:\n                words.append(current_word)\n                current_word = ''\n    \n    if current_word:\n        words.append(current_word)\n    \n    # If no words found, return original string\n    if not words:\n        return s\n    \n    # Reverse the words list\n    words.reverse()\n    \n    # Reconstruct string with original spacing pattern\n    result = ''\n    word_index = 0\n    current_word = ''\n    \n    for char in s:\n        if char != ' ':\n            if not current_word and word_index < len(words):\n                current_word = words[word_index]\n                word_index += 1\n            if current_word:\n                result += current_word[0]\n                current_word = current_word[1:]\n        else:\n            result += char\n    \n    return result",
      "test_cases": [
        {"input": ["  hello   world  "], "expected": "  world   hello  "},
        {"input": ["the sky is blue"], "expected": "blue is sky the"},
        {"input": ["  hello world  "], "expected": "  world hello  "},
        {"input": ["a"], "expected": "a"},
        {"input": [""], "expected": ""}
      ]
    },
    {
      "id": 19,
      "title": "First Non-Repeating Character Finder",
      "statement": "Write a function that finds the first non-repeating character in a string and returns its index. If no such character exists, return -1. For example, in 'leetcode', the first non-repeating character is 'l' at index 0. In 'loveleetcode', it's 'v' at index 2.",
      "function_signature": "def first_unique_char(s):",
      "categories": ["string_processing", "data_structure_fundamentals"],
      "python_constructs": ["dictionary", "string_iteration", "collections_counter"],
      "hints": [
        "First pass: count frequency of each character using a dictionary",
        "Second pass: iterate through string to find first character with count 1",
        "Return the index of the first unique character found"
      ],
      "solution": "def first_unique_char(s):\n    if not s:\n        return -1\n    \n    # Count frequency of each character\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find first character with count 1\n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n    \n    return -1",
      "test_cases": [
        {"input": ["leetcode"], "expected": 0},
        {"input": ["loveleetcode"], "expected": 2},
        {"input": ["aabb"], "expected": -1},
        {"input": [""], "expected": -1},
        {"input": ["abcdef"], "expected": 0}
      ]
    },
    {
      "id": 20,
      "title": "Character Frequency Analysis",
      "statement": "Create a function that returns a dictionary containing the frequency of each character in a string, sorted by frequency in descending order, then alphabetically for ties. For example, 'programming' should return {'r': 2, 'g': 2, 'm': 2, 'a': 1, 'i': 1, 'n': 1, 'o': 1, 'p': 1}.",
      "function_signature": "def char_frequency_analysis(s):",
      "categories": ["string_processing", "data_structure_fundamentals"],
      "python_constructs": ["collections_counter", "dictionary", "sorting", "lambda_functions"],
      "hints": [
        "Use Counter to get character frequencies",
        "Sort by frequency (descending) and then alphabetically (ascending)",
        "Convert back to dictionary maintaining the sorted order"
      ],
      "solution": "def char_frequency_analysis(s):\n    from collections import Counter\n    \n    if not s:\n        return {}\n    \n    # Count character frequencies\n    char_count = Counter(s)\n    \n    # Sort by frequency (descending) then alphabetically (ascending)\n    sorted_items = sorted(char_count.items(), key=lambda x: (-x[1], x[0]))\n    \n    return dict(sorted_items)",
      "test_cases": [
        {"input": ["programming"], "expected": {"r": 2, "g": 2, "m": 2, "a": 1, "i": 1, "n": 1, "o": 1, "p": 1}},
        {"input": ["hello"], "expected": {"l": 2, "e": 1, "h": 1, "o": 1}},
        {"input": [""], "expected": {}},
        {"input": ["aaa"], "expected": {"a": 3}},
        {"input": ["abcdef"], "expected": {"a": 1, "b": 1, "c": 1, "d": 1, "e": 1, "f": 1}}
      ]
    },
    {
      "id": 21,
      "title": "String Compression Algorithm",
      "statement": "Implement a string compression function that replaces consecutive repeated characters with the character followed by the count. For example, 'aaabbc' becomes 'a3b2c1'. If the compressed string is longer than the original, return the original string. Single characters should still show count of 1.",
      "function_signature": "def compress_string(s):",
      "categories": ["string_processing", "pattern_recognition"],
      "python_constructs": ["string_building", "iteration", "conditional_logic"],
      "hints": [
        "Iterate through the string counting consecutive characters",
        "Build compressed string by appending character + count",
        "Compare lengths and return shorter version"
      ],
      "solution": "def compress_string(s):\n    if not s:\n        return s\n    \n    compressed = []\n    current_char = s[0]\n    count = 1\n    \n    for i in range(1, len(s)):\n        if s[i] == current_char:\n            count += 1\n        else:\n            compressed.append(current_char + str(count))\n            current_char = s[i]\n            count = 1\n    \n    # Add the last group\n    compressed.append(current_char + str(count))\n    \n    compressed_string = ''.join(compressed)\n    \n    # Return shorter version\n    return compressed_string if len(compressed_string) < len(s) else s",
      "test_cases": [
        {"input": ["aaabbc"], "expected": "a3b2c1"},
        {"input": ["abcdef"], "expected": "abcdef"},
        {"input": ["aabbcc"], "expected": "aabbcc"},
        {"input": ["aaaaaaaaaa"], "expected": "a10"},
        {"input": [""], "expected": ""}
      ]
    },
    {
      "id": 22,
      "title": "Remove Duplicate Characters",
      "statement": "Write a function that removes duplicate characters from a string while preserving the order of first occurrence. For example, 'programming' becomes 'progamin'. The function should be case-sensitive and handle empty strings gracefully.",
      "function_signature": "def remove_duplicates(s):",
      "categories": ["string_processing", "data_structure_fundamentals"],
      "python_constructs": ["set", "string_building", "iteration"],
      "hints": [
        "Use a set to keep track of characters already seen",
        "Build result string by adding only unseen characters",
        "Maintain order by processing characters sequentially"
      ],
      "solution": "def remove_duplicates(s):\n    if not s:\n        return s\n    \n    seen = set()\n    result = []\n    \n    for char in s:\n        if char not in seen:\n            seen.add(char)\n            result.append(char)\n    \n    return ''.join(result)",
      "test_cases": [
        {"input": ["programming"], "expected": "progamin"},
        {"input": ["hello"], "expected": "helo"},
        {"input": [""], "expected": ""},
        {"input": ["aaa"], "expected": "a"},
        {"input": ["abcdef"], "expected": "abcdef"}
      ]
    },
    {
      "id": 23,
      "title": "Longest Common Prefix Finder",
      "statement": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. For example, ['flower', 'flow', 'flight'] should return 'fl'. Handle edge cases like empty arrays or single strings.",
      "function_signature": "def longest_common_prefix(strs):",
      "categories": ["string_processing", "array_manipulation"],
      "python_constructs": ["string_slicing", "iteration", "conditional_logic"],
      "hints": [
        "Compare characters at the same position across all strings",
        "Stop when you find a mismatch or reach the end of any string",
        "Handle edge cases: empty array, single string, empty strings"
      ],
      "solution": "def longest_common_prefix(strs):\n    if not strs:\n        return ''\n    \n    if len(strs) == 1:\n        return strs[0]\n    \n    # Find the shortest string length\n    min_length = min(len(s) for s in strs)\n    \n    prefix = ''\n    \n    for i in range(min_length):\n        char = strs[0][i]\n        \n        # Check if this character is common across all strings\n        for string in strs[1:]:\n            if string[i] != char:\n                return prefix\n        \n        prefix += char\n    \n    return prefix",
      "test_cases": [
        {"input": [["flower", "flow", "flight"]], "expected": "fl"},
        {"input": [["dog", "racecar", "car"]], "expected": ""},
        {"input": [["interspecies", "interstellar", "interstate"]], "expected": "inters"},
        {"input": [[]], "expected": ""},
        {"input": [["alone"]], "expected": "alone"}
      ]
    },
    {
      "id": 24,
      "title": "Email Validation System",
      "statement": "Create a robust email validation function that checks if an email address follows basic email format rules: contains exactly one '@' symbol, has valid local and domain parts, domain has at least one dot, and no consecutive dots. For example, 'user@example.com' is valid, but 'user@.com' or 'user..name@example.com' are invalid.",
      "function_signature": "def is_valid_email(email):",
      "categories": ["string_processing", "pattern_recognition", "logic_and_conditional"],
      "python_constructs": ["string_methods", "regular_expressions", "conditional_logic"],
      "hints": [
        "Check for exactly one '@' symbol to separate local and domain parts",
        "Validate local part: no consecutive dots, not starting/ending with dot",
        "Validate domain part: must contain at least one dot, valid characters"
      ],
      "solution": "def is_valid_email(email):\n    import re\n    \n    if not email or not isinstance(email, str):\n        return False\n    \n    # Check for exactly one @ symbol\n    if email.count('@') != 1:\n        return False\n    \n    local, domain = email.split('@')\n    \n    # Validate local part\n    if not local or len(local) > 64:\n        return False\n    \n    if local.startswith('.') or local.endswith('.'):\n        return False\n    \n    if '..' in local:\n        return False\n    \n    # Check local part characters (alphanumeric, dots, hyphens, underscores)\n    if not re.match(r'^[a-zA-Z0-9._-]+$', local):\n        return False\n    \n    # Validate domain part\n    if not domain or len(domain) > 255:\n        return False\n    \n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    \n    if '..' in domain:\n        return False\n    \n    # Domain must contain at least one dot\n    if '.' not in domain:\n        return False\n    \n    # Check domain format\n    domain_parts = domain.split('.')\n    for part in domain_parts:\n        if not part or not re.match(r'^[a-zA-Z0-9-]+$', part):\n            return False\n        if part.startswith('-') or part.endswith('-'):\n            return False\n    \n    return True",
      "test_cases": [
        {"input": ["user@example.com"], "expected": true},
        {"input": ["invalid.email"], "expected": false},
        {"input": ["user@.com"], "expected": false},
        {"input": ["user..name@example.com"], "expected": false},
        {"input": ["valid_email@test-domain.co.uk"], "expected": true}
      ]
    },
    {
      "id": 25,
      "title": "String Pattern Matching",
      "statement": "Write a function that checks if a string matches a simple pattern where '*' represents zero or more characters and '?' represents exactly one character. For example, 'hello' matches 'h*o' and 'h?llo' but not 'h?o'. This is a simplified version of wildcard pattern matching.",
      "function_signature": "def matches_pattern(text, pattern):",
      "categories": ["string_processing", "pattern_recognition"],
      "python_constructs": ["recursion", "conditional_logic", "string_slicing"],
      "hints": [
        "Use recursion to handle different cases: exact match, '?', and '*'",
        "For '*', try matching zero characters or one or more characters",
        "Handle base cases: empty pattern, empty text"
      ],
      "solution": "def matches_pattern(text, pattern):\n    def helper(t_idx, p_idx):\n        # Base cases\n        if p_idx == len(pattern):\n            return t_idx == len(text)\n        \n        if t_idx == len(text):\n            # Check if remaining pattern is all '*'\n            return all(c == '*' for c in pattern[p_idx:])\n        \n        # Current pattern character\n        p_char = pattern[p_idx]\n        \n        if p_char == '*':\n            # Try matching zero characters or one or more\n            return (helper(t_idx, p_idx + 1) or  # zero characters\n                    helper(t_idx + 1, p_idx))       # one or more characters\n        \n        elif p_char == '?' or p_char == text[t_idx]:\n            # Exact match or single character wildcard\n            return helper(t_idx + 1, p_idx + 1)\n        \n        else:\n            # No match\n            return False\n    \n    return helper(0, 0)",
      "test_cases": [
        {"input": ["hello", "h*o"], "expected": true},
        {"input": ["hello", "h?llo"], "expected": true},
        {"input": ["hello", "h?o"], "expected": false},
        {"input": ["", "*"], "expected": true},
        {"input": ["abc", "a*c"], "expected": true}
      ]
    },
    {
      "id": 26,
      "title": "Word Count and Statistics",
      "statement": "Create a function that analyzes text and returns statistics including word count, character count (excluding spaces), average word length, and the longest word. For example, 'Hello world programming' should return {'word_count': 3, 'char_count': 18, 'avg_word_length': 6.0, 'longest_word': 'programming'}.",
      "function_signature": "def text_statistics(text):",
      "categories": ["string_processing", "mathematical_algorithms"],
      "python_constructs": ["string_methods", "list_comprehension", "mathematical_operations"],
      "hints": [
        "Split text into words and filter out empty strings",
        "Count characters excluding spaces",
        "Calculate average word length and find longest word"
      ],
      "solution": "def text_statistics(text):\n    if not text or not text.strip():\n        return {\n            'word_count': 0,\n            'char_count': 0,\n            'avg_word_length': 0.0,\n            'longest_word': ''\n        }\n    \n    # Split into words and filter empty strings\n    words = [word for word in text.split() if word]\n    \n    if not words:\n        return {\n            'word_count': 0,\n            'char_count': 0,\n            'avg_word_length': 0.0,\n            'longest_word': ''\n        }\n    \n    word_count = len(words)\n    char_count = len(text.replace(' ', ''))\n    total_word_length = sum(len(word) for word in words)\n    avg_word_length = total_word_length / word_count\n    longest_word = max(words, key=len)\n    \n    return {\n        'word_count': word_count,\n        'char_count': char_count,\n        'avg_word_length': round(avg_word_length, 1),\n        'longest_word': longest_word\n    }",
      "test_cases": [
        {"input": ["Hello world programming"], "expected": {"word_count": 3, "char_count": 18, "avg_word_length": 6.0, "longest_word": "programming"}},
        {"input": [""], "expected": {"word_count": 0, "char_count": 0, "avg_word_length": 0.0, "longest_word": ""}},
        {"input": ["a"], "expected": {"word_count": 1, "char_count": 1, "avg_word_length": 1.0, "longest_word": "a"}},
        {"input": ["  multiple   spaces  "], "expected": {"word_count": 2, "char_count": 13, "avg_word_length": 6.5, "longest_word": "multiple"}},
        {"input": ["short verylongword"], "expected": {"word_count": 2, "char_count": 17, "avg_word_length": 8.5, "longest_word": "verylongword"}}
      ]
    },
    {
      "id": 27,
      "title": "String Rotation Checker",
      "statement": "Write a function to check if one string is a rotation of another. For example, 'waterbottle' is a rotation of 'erbottlewat'. A rotation means you can move characters from the beginning to the end. Both strings must have the same length and contain the same characters.",
      "function_signature": "def is_rotation(s1, s2):",
      "categories": ["string_processing", "pattern_recognition"],
      "python_constructs": ["string_concatenation", "string_methods", "conditional_logic"],
      "hints": [
        "Check if lengths are equal first",
        "A rotation of s1 will be a substring of s1 + s1",
        "Use the 'in' operator to check if s2 is a substring of s1 + s1"
      ],
      "solution": "def is_rotation(s1, s2):\n    # Check basic conditions\n    if not s1 and not s2:\n        return True\n    \n    if len(s1) != len(s2) or not s1 or not s2:\n        return False\n    \n    # Check if s2 is a substring of s1 + s1\n    return s2 in s1 + s1",
      "test_cases": [
        {"input": ["waterbottle", "erbottlewat"], "expected": true},
        {"input": ["abcde", "cdeab"], "expected": true},
        {"input": ["abcde", "abced"], "expected": false},
        {"input": ["", ""], "expected": true},
        {"input": ["a", "b"], "expected": false}
      ]
    },
    {
      "id": 28,
      "title": "Phone Number Formatter",
      "statement": "Create a function that formats a phone number string into a standard format. Given a string containing only digits, format it as '(XXX) XXX-XXXX' for 10-digit numbers. If the number has 11 digits and starts with '1', remove the '1' and format the remaining 10 digits. Return 'Invalid' for any other cases.",
      "function_signature": "def format_phone_number(phone):",
      "categories": ["string_processing", "logic_and_conditional"],
      "python_constructs": ["string_methods", "conditional_logic", "string_formatting"],
      "hints": [
        "Remove all non-digit characters first",
        "Check length and handle 11-digit numbers starting with '1'",
        "Format 10-digit numbers using string slicing or formatting"
      ],
      "solution": "def format_phone_number(phone):\n    if not phone:\n        return 'Invalid'\n    \n    # Remove all non-digit characters\n    digits = ''.join(c for c in phone if c.isdigit())\n    \n    # Handle different cases\n    if len(digits) == 10:\n        # Format as (XXX) XXX-XXXX\n        return f'({digits[:3]}) {digits[3:6]}-{digits[6:]}'\n    \n    elif len(digits) == 11 and digits[0] == '1':\n        # Remove leading '1' and format remaining 10 digits\n        remaining = digits[1:]\n        return f'({remaining[:3]}) {remaining[3:6]}-{remaining[6:]}'\n    \n    else:\n        return 'Invalid'",
      "test_cases": [
        {"input": ["1234567890"], "expected": "(123) 456-7890"},
        {"input": ["11234567890"], "expected": "(123) 456-7890"},
        {"input": ["21234567890"], "expected": "Invalid"},
        {"input": ["123-456-7890"], "expected": "(123) 456-7890"},
        {"input": ["123456789"], "expected": "Invalid"}
      ]
    },
    {
      "id": 29,
      "title": "Caesar Cipher Implementation",
      "statement": "Implement a Caesar cipher that shifts each letter in a string by a given number of positions in the alphabet. Preserve case and leave non-alphabetic characters unchanged. For example, 'Hello World' with shift 3 becomes 'Khoor Zruog'. Handle negative shifts and shifts larger than 26.",
      "function_signature": "def caesar_cipher(text, shift):",
      "categories": ["string_processing", "mathematical_algorithms"],
      "python_constructs": ["string_methods", "modulo_operator", "chr_ord_functions"],
      "hints": [
        "Use modulo 26 to handle shifts larger than alphabet size",
        "Handle uppercase and lowercase letters separately",
        "Use ord() and chr() functions for character conversion"
      ],
      "solution": "def caesar_cipher(text, shift):\n    if not text:\n        return text\n    \n    # Normalize shift to be within 0-25 range\n    shift = shift % 26\n    \n    result = []\n    \n    for char in text:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            if char.isupper():\n                # Shift uppercase letters\n                shifted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            else:\n                # Shift lowercase letters\n                shifted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            # Keep non-alphabetic characters unchanged\n            result.append(char)\n    \n    return ''.join(result)",
      "test_cases": [
        {"input": ["Hello World", 3], "expected": "Khoor Zruog"},
        {"input": ["xyz", 3], "expected": "abc"},
        {"input": ["ABC", -1], "expected": "ZAB"},
        {"input": ["Hello123!", 1], "expected": "Ifmmp123!"},
        {"input": ["", 5], "expected": ""}
      ]
    },
    {
      "id": 30,
      "title": "Title Case Converter",
      "statement": "Write a function that converts a string to title case, where the first letter of each word is capitalized and the rest are lowercase. However, certain small words should remain lowercase unless they are the first or last word. Small words include: 'a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'of', 'on', 'or', 'the', 'to', 'up'.",
      "function_signature": "def title_case_smart(text):",
      "categories": ["string_processing", "logic_and_conditional"],
      "python_constructs": ["string_methods", "list_comprehension", "conditional_logic"],
      "hints": [
        "Split the text into words and handle each word individually",
        "Define a set of small words that should remain lowercase",
        "Always capitalize the first and last words regardless of the rule"
      ],
      "solution": "def title_case_smart(text):\n    if not text:\n        return text\n    \n    small_words = {'a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', \n                   'if', 'in', 'of', 'on', 'or', 'the', 'to', 'up'}\n    \n    words = text.lower().split()\n    \n    if not words:\n        return text\n    \n    result = []\n    \n    for i, word in enumerate(words):\n        # Always capitalize first and last word\n        if i == 0 or i == len(words) - 1:\n            result.append(word.capitalize())\n        # Check if it's a small word\n        elif wor