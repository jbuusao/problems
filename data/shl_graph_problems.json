{
  "problems": [
    {
      "id": 1,
      "title": "Island Counter in 2D Grid",
      "statement": "Given a 2D grid map of '1's (land) and '0's (water), count the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\nInput: grid = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]\nOutput: 1\n\nExample 2:\nInput: grid = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]\nOutput: 3",
      "function_signature": "def count_islands(grid):",
      "categories": ["graph_theory_basic", "array_manipulation", "search_algorithms"],
      "python_constructs": ["nested_loops", "recursion", "2d_arrays", "conditional_statements", "function_definition"],
      "hints": [
        "Use depth-first search (DFS) to explore connected land cells",
        "When you find a '1', perform DFS to mark all connected land as visited",
        "Keep track of visited cells to avoid counting the same island multiple times"
      ],
      "solution": "def count_islands(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    island_count = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            visited[r][c] or grid[r][c] == '0'):\n            return\n        \n        visited[r][c] = True\n        # Explore all 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1' and not visited[i][j]:\n                dfs(i, j)\n                island_count += 1\n    \n    return island_count",
      "test_cases": [
        {"input": [[["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]]], "expected": 1},
        {"input": [[["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]], "expected": 3},
        {"input": [[[]]], "expected": 0},
        {"input": [[["0","0","0"],["0","0","0"],["0","0","0"]]], "expected": 0},
        {"input": [[["1"]]], "expected": 1}
      ]
    },
    {
      "id": 2,
      "title": "Shortest Path in Unweighted Grid",
      "statement": "Find the shortest path from start position to end position in a 2D grid.\n\nThe grid contains:\n- 0: walkable cell\n- 1: obstacle (cannot pass through)\n- 2: start position\n- 3: end position\n\nYou can move up, down, left, or right. Return the length of the shortest path, or -1 if no path exists.\n\nExample:\nInput: grid = [[2,0,0,3],[0,1,1,0],[0,0,0,0]]\nOutput: 3\nExplanation: Path is (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (2,3) -> (1,3) -> (0,3), but shortest is (0,0) -> (0,1) -> (0,2) -> (0,3) with length 3.",
      "function_signature": "def shortest_path(grid):",
      "categories": ["graph_theory_basic", "search_algorithms", "array_manipulation"],
      "python_constructs": ["queue", "bfs", "while_loop", "collections", "tuple_unpacking"],
      "hints": [
        "Use Breadth-First Search (BFS) to find the shortest path",
        "Start from the position marked with '2' and search for position marked with '3'",
        "Keep track of visited cells and the distance from start"
      ],
      "solution": "from collections import deque\n\ndef shortest_path(grid):\n    if not grid or not grid[0]:\n        return -1\n    \n    rows, cols = len(grid), len(grid[0])\n    start = end = None\n    \n    # Find start and end positions\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 2:\n                start = (i, j)\n            elif grid[i][j] == 3:\n                end = (i, j)\n    \n    if not start or not end:\n        return -1\n    \n    queue = deque()\n    queue.append((start[0], start[1], 0))  # (row, col, distance)\n    visited = set([start])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while queue:\n        row, col, dist = queue.popleft()\n        \n        if (row, col) == end:\n            return dist\n        \n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            if (0 <= new_row < rows and 0 <= new_col < cols and \n                (new_row, new_col) not in visited and \n                grid[new_row][new_col] != 1):\n                \n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, dist + 1))\n    \n    return -1",
      "test_cases": [
        {"input": [[[2,0,0,3],[0,1,1,0],[0,0,0,0]]], "expected": 3},
        {"input": [[[2,1,3]]], "expected": -1},
        {"input": [[[2,0,3]]], "expected": 2},
        {"input": [[[2,1,1],[0,0,0],[3,0,1]]], "expected": 4},
        {"input": [[[2],[3]]], "expected": 1}
      ]
    },
    {
      "id": 4,
      "title": "Valid Path Exists",
      "statement": "Given a 2D grid where 0 represents an empty cell and 1 represents an obstacle, determine if there exists a valid path from the top-left corner (0,0) to the bottom-right corner.\n\nYou can move up, down, left, or right to adjacent cells that are not obstacles.\n\nExample 1:\nInput: grid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: True\n\nExample 2:\nInput: grid = [[0,1],[1,0]]\nOutput: False",
      "function_signature": "def has_valid_path(grid):",
      "categories": ["graph_theory_basic", "array_manipulation", "search_algorithms"],
      "python_constructs": ["nested_loops", "recursion", "2d_arrays", "boolean_return", "base_cases"],
      "hints": [
        "Use DFS or BFS to explore possible paths from start to end",
        "Mark visited cells to avoid infinite loops",
        "Return True as soon as you reach the destination"
      ],
      "solution": "def has_valid_path(grid):\n    if not grid or not grid[0] or grid[0][0] == 1:\n        return False\n    \n    rows, cols = len(grid), len(grid[0])\n    target = (rows - 1, cols - 1)\n    \n    if grid[target[0]][target[1]] == 1:\n        return False\n    \n    if rows == 1 and cols == 1:\n        return True\n    \n    visited = set()\n    \n    def dfs(row, col):\n        if (row, col) == target:\n            return True\n        \n        if (row < 0 or row >= rows or col < 0 or col >= cols or \n            (row, col) in visited or grid[row][col] == 1):\n            return False\n        \n        visited.add((row, col))\n        \n        # Explore all 4 directions\n        return (dfs(row + 1, col) or dfs(row - 1, col) or \n                dfs(row, col + 1) or dfs(row, col - 1))\n    \n    return dfs(0, 0)",
      "test_cases": [
        {"input": [[[0,0,0],[0,1,0],[0,0,0]]], "expected": true},
        {"input": [[[0,1],[1,0]]], "expected": false},
        {"input": [[[0]]], "expected": true},
        {"input": [[[1]]], "expected": false},
        {"input": [[[0,0,0,0],[0,1,1,0],[0,0,0,0]]], "expected": true}
      ]
    },
    {
      "id": 5,
      "title": "Network Delay Time",
      "statement": "You are given a network of n nodes, labeled from 1 to n. You are also given a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node k. Return the time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.\n\nExample:\nInput: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\nExplanation: Signal starts at node 2, reaches node 1 and 3 in time 1, then reaches node 4 in time 2.",
      "function_signature": "def network_delay_time(times, n, k):",
      "categories": ["graph_theory_basic", "search_algorithms", "mathematical_algorithms"],
      "python_constructs": ["dictionary", "list_comprehension", "heapq", "while_loop", "max_function"],
      "hints": [
        "Use Dijkstra's algorithm to find shortest paths from the source node",
        "Build an adjacency list representation of the graph first",
        "Return the maximum time among all reachable nodes"
      ],
      "solution": "import heapq\nfrom collections import defaultdict\n\ndef network_delay_time(times, n, k):\n    # Build adjacency list\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    # Dijkstra's algorithm\n    distances = {}\n    heap = [(0, k)]  # (distance, node)\n    \n    while heap:\n        dist, node = heapq.heappop(heap)\n        \n        if node in distances:\n            continue\n        \n        distances[node] = dist\n        \n        for neighbor, weight in graph[node]:\n            if neighbor not in distances:\n                heapq.heappush(heap, (dist + weight, neighbor))\n    \n    # Check if all nodes are reachable\n    if len(distances) != n:\n        return -1\n    \n    return max(distances.values())",
      "test_cases": [
        {"input": [[[2,1,1],[2,3,1],[3,4,1]], 4, 2], "expected": 2},
        {"input": [[[1,2,1]], 2, 1], "expected": 1},
        {"input": [[[1,2,1]], 2, 2], "expected": -1},
        {"input": [[[1,2,1],[1,3,2],[2,3,1]], 3, 1], "expected": 2},
        {"input": [[], 1, 1], "expected": 0}
      ]
    },
    {
      "id": 6,
      "title": "Course Schedule Validator",
      "statement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nReturn true if you can finish all courses. Otherwise, return false.\n\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: Take course 0, then course 1.\n\nExample 2:\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: Circular dependency - cannot complete either course.",
      "function_signature": "def can_finish_courses(num_courses, prerequisites):",
      "categories": ["graph_theory_basic", "logic_and_conditional", "search_algorithms"],
      "python_constructs": ["dictionary", "list", "recursion", "set", "for_loop"],
      "hints": [
        "This is a cycle detection problem in a directed graph",
        "Use DFS with three states: unvisited, visiting, visited",
        "If you encounter a node in 'visiting' state, there's a cycle"
      ],
      "solution": "def can_finish_courses(num_courses, prerequisites):\n    # Build adjacency list\n    graph = {i: [] for i in range(num_courses)}\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    # States: 0 = unvisited, 1 = visiting, 2 = visited\n    state = [0] * num_courses\n    \n    def has_cycle(course):\n        if state[course] == 1:  # Currently visiting - cycle detected\n            return True\n        if state[course] == 2:  # Already visited - no cycle from this node\n            return False\n        \n        state[course] = 1  # Mark as visiting\n        \n        # Check all prerequisites\n        for prereq in graph[course]:\n            if has_cycle(prereq):\n                return True\n        \n        state[course] = 2  # Mark as visited\n        return False\n    \n    # Check each course for cycles\n    for course in range(num_courses):\n        if state[course] == 0 and has_cycle(course):\n            return False\n    \n    return True",
      "test_cases": [
        {"input": [2, [[1,0]]], "expected": true},
        {"input": [2, [[1,0],[0,1]]], "expected": false},
        {"input": [1, []], "expected": true},
        {"input": [3, [[1,0],[2,1]]], "expected": true},
        {"input": [4, [[1,0],[2,1],[3,2],[1,3]]], "expected": false}
      ]
    },
    {
      "id": 7,
      "title": "Word Ladder Chain Length",
      "statement": "Given two words, beginWord and endWord, and a dictionary wordList, return the length of the shortest transformation sequence from beginWord to endWord.\n\nA transformation sequence is where each adjacent pair of words differs by exactly one letter. Each intermediate word must exist in the wordList.\n\nReturn 0 if there is no such transformation sequence.\n\nExample:\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"",
      "function_signature": "def word_ladder_length(begin_word, end_word, word_list):",
      "categories": ["graph_theory_basic", "string_processing", "search_algorithms"],
      "python_constructs": ["queue", "set", "string_methods", "collections", "while_loop"],
      "hints": [
        "Treat each word as a node and words differing by one letter as connected",
        "Use BFS to find the shortest path from begin_word to end_word",
        "For each word, try changing each character to find valid neighbors"
      ],
      "solution": "from collections import deque\n\ndef word_ladder_length(begin_word, end_word, word_list):\n    if end_word not in word_list:\n        return 0\n    \n    word_set = set(word_list)\n    queue = deque()\n    queue.append((begin_word, 1))\n    visited = set([begin_word])\n    \n    while queue:\n        current_word, length = queue.popleft()\n        \n        if current_word == end_word:\n            return length\n        \n        # Try changing each character\n        for i in range(len(current_word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == current_word[i]:\n                    continue\n                \n                next_word = current_word[:i] + c + current_word[i+1:]\n                \n                if next_word in word_set and next_word not in visited:\n                    visited.add(next_word)\n                    queue.append((next_word, length + 1))\n    \n    return 0",
      "test_cases": [
        {"input": ["hit", "cog", ["hot","dot","dog","lot","log","cog"]], "expected": 5},
        {"input": ["hit", "cog", ["hot","dot","dog","lot","log"]], "expected": 0},
        {"input": ["a", "c", ["a","b","c"]], "expected": 2},
        {"input": ["hot", "dog", ["hot","dog"]], "expected": 0},
        {"input": ["hot", "hot", ["hot"]], "expected": 1}
      ]
    },
    {
      "id": 9,
      "title": "Social Network Friend Circles",
      "statement": "Given a 2D matrix representing friendships where matrix[i][j] = 1 means person i and person j are friends, find the number of friend circles.\n\nA friend circle is a group of people who are all friends with each other (directly or indirectly).\n\nExample:\nInput: matrix = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2\nExplanation: Person 0 and 1 are friends, person 2 is alone. So 2 circles.\n\nNote: matrix[i][i] = 1 (person is friends with themselves)",
      "function_signature": "def find_friend_circles(matrix):",
      "categories": ["graph_theory_basic", "array_manipulation", "search_algorithms"],
      "python_constructs": ["nested_loops", "2d_arrays", "set", "recursion", "range_function"],
      "hints": [
        "This is finding connected components in an undirected graph",
        "Use DFS to explore each friend group starting from unvisited people",
        "The adjacency matrix is symmetric since friendship is mutual"
      ],
      "solution": "def find_friend_circles(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    n = len(matrix)\n    visited = set()\n    circles = 0\n    \n    def dfs(person):\n        visited.add(person)\n        for friend in range(n):\n            if matrix[person][friend] == 1 and friend not in visited:\n                dfs(friend)\n    \n    for person in range(n):\n        if person not in visited:\n            dfs(person)\n            circles += 1\n    \n    return circles",
      "test_cases": [
        {"input": [[[1,1,0],[1,1,0],[0,0,1]]], "expected": 2},
        {"input": [[[1,1,0],[1,1,1],[0,1,1]]], "expected": 1},
        {"input": [[[1,0,0],[0,1,0],[0,0,1]]], "expected": 3},
        {"input": [[[1]]], "expected": 1},
        {"input": [[[1,1],[1,1]]], "expected": 1}
      ]
    },
    {
      "id": 10,
      "title": "Minimum Steps to Reach Target",
      "statement": "You are standing at position 0 on an infinite number line. There is a goal at position target.\n\nOn each move, you can either go left or right. During the nth move (starting from 1), you take n steps. So for the first move you take 1 step, for the second move you take 2 steps, etc.\n\nReturn the minimum number of moves required to reach the target.\n\nExample 1:\nInput: target = 3\nOutput: 2\nExplanation: Move 1: +1 (position = 1), Move 2: +2 (position = 3)\n\nExample 2:\nInput: target = 2\nOutput: 3\nExplanation: Move 1: +1 (position = 1), Move 2: -2 (position = -1), Move 3: +3 (position = 2)",
      "function_signature": "def min_steps_to_target(target):",
      "categories": ["graph_theory_basic", "mathematical_algorithms", "optimization_problems"],
      "python_constructs": ["while_loop", "mathematical_operations", "conditional_statements", "abs_function"],
      "hints": [
        "Think of this as finding the minimum steps where sum of some subset equals target",
        "Keep adding steps until the sum is >= target",
        "If sum - target is even, you can flip some steps to reach exactly target"
      ],
      "solution": "def min_steps_to_target(target):\n    target = abs(target)  # Due to symmetry, we can work with positive target\n    \n    step = 0\n    sum_steps = 0\n    \n    # Keep adding steps until we reach or exceed target\n    while sum_steps < target or (sum_steps - target) % 2 != 0:\n        step += 1\n        sum_steps += step\n    \n    return step",
      "test_cases": [
        {"input": [3], "expected": 2},
        {"input": [2], "expected": 3},
        {"input": [1], "expected": 1},
        {"input": [4], "expected": 3},
        {"input": [-3], "expected": 2}
      ]
    }
  ]
}
